START 13    # PROGRAM WILL BE LOADED AT ADDRESS 13 IN RAM
            # IT WILL FILL ALL PREVIOUS ADDRESSES (0-12) WITH 0 AND 
            # PHYSICAL ADDRESS = LOGICAL ADDRESS + RELOCATION VALUE (13)

# ADDRESS TABLE
#===============================================================================
JMP Main                                            # ADDRESS 13 -> MAIN FUNCTION
JMP Return_From_Add1                                # ADDRESS 14 
JMP Return_From_Add2                                # ADDRESS 15 
#===============================================================================

Main: # MAIN FUNCTION WITH NO ARGUMENT
    # ALL THE ARGUMENTS AND RETURN VALUES ARE STORED IN STACK 
    # WHICH STARTS FROM ADDRESS 0
    XOR SP, SP # RESET STACK POINTER (SP) WHICH IS ORIGINALLY R5

#=======================  add function 1 ========================================
    XOR R0, R0  # RESET (R0)
    XOR R1, R1  # RESET (R1)
    XOR R2, R2  # RESET (R2)

    ADD R0, 1  # R0 = 1 => IT SAVES FIRST ARGUMENT OF VALUE 1
    ADD R1, 2  # R1 = 2 => IT SAVES SECOND ARGUMENT OF VALUE 2
    ADD R2, 14  # R2 = 14 => IT SAVES RETURN ADDRESS 14 WHICH WILL JUMP TO Return_From_Add1

    # ARGUMENTS ARE ALWAYS PUSHED IN REVERSE ORDER INTO STACK
    STORE [SP], R1  # PUSH 2 (SECOND ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R0  # PUSH 1 (FIRST ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R2  # PUSH RETURN ADDRESS TO STACK
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP Add

Return_From_Add1:
    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R3, [SP]   # POP RETURN VALUE FROM STACK 

#=======================  add function 2 ========================================
    XOR R0, R0  # RESET (R0)
    XOR R1, R1  # RESET (R1)
    XOR R2, R2  # RESET (R2)

    ADD R0, 3  # R0 = 3 => IT SAVES FIRST ARGUMENT OF VALUE 3
    ADD R1, 4  # R1 = 4 => IT SAVES SECOND ARGUMENT OF VALUE 4
    ADD R2, 15  # R2 = 15 => IT SAVES RETURN ADDRESS 15 WHICH WILL JUMP TO Return_From_Add2

    # ARGUMENTS ARE ALWAYS PUSHED IN REVERSE ORDER INTO STACK
    STORE [SP], R1  # PUSH 4 (SECOND ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R0  # PUSH 3 (FIRST ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R2  # PUSH RETURN ADDRESS TO STACK
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP Add

Return_From_Add2:
    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R3, [SP]   # POP RETURN VALUE FROM STACK 

    JMP Exit 

Add: # ADD FUNCTION WITH A & B ARGUMENTS
    # SINCE ADD FUNCTION USES A, B AND C WHICH ARE LOCAL VARIABLES
    # OMITING THEM AND USING ONLY REGISTERS ARE ENOUGH
    # BECAUSE IT WILL NOT CHANGE MEANING OF PROGRAM

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R2, [SP]   # POP RETURN_ADDRESS FROM STACK

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R0, [SP]   # POP A (R0) FROM STACK

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R1, [SP]   # POP B (R1)FROM STACK

    ADD R0, R1      # A = A + B (R0 = R0 + R1)

    STORE [SP], R0  # PUSH RETURN VALUE TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMPREG R2       # RETURN TO CALLED FUNCTION

Exit:              # PUT CPU INTO NOP (NO OPERATION)
    JMP Exit       # PUT CPU INTO NOP (NO OPERATION)
