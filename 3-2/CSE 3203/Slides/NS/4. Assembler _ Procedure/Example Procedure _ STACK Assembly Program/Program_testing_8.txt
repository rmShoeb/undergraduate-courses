START 11    # PROGRAM WILL BE LOADED AT ADDRESS 11 IN RAM
            # IT WILL FILL ALL PREVIOUS ADDRESSES (0-10) WITH 0 AND 
            # PHYSICAL ADDRESS = LOGICAL ADDRESS + RELOCATION VALUE (11)

# ADDRESS TABLE
#===============================================================================
JMP MAIN                                            # ADDRESS 11 -> MAIN FUNCTION
JMP RETURN_FROM_SOFTWARE_INTERRUPT_INPUT1           # ADDRESS 12 
JMP RETURN_FROM_SOFTWARE_INTERRUPT_INPUT2           # ADDRESS 13 
JMP RETURN_FROM_SOFTWARE_INTERRUPT_OUTPUT_PRINT     # ADDRESS 14
#===============================================================================
JMP HARDWARE_INTERRUPT_INPUT_FOUND                  # ADDRESS 15 -> FIXED ADDRESS FOR HARDWARE INPUT INTERRUPT
#===============================================================================

SOFTWARE_INTERRUPT_OUTPUT_PRINT:
    JMP HARDWARE_INTERRUPT_OUTPUT_PRINT
    RETURN_FROM_HARDWARE_INTERRUPT_OUTPUT_PRINT:

        SUB SP, 1       # SET STACK TO PREVIOUS STACK LOCATION
        LOAD R3, [SP]   # POP RETURN ADDRESS TO R3 FROM STACK

        JMPREG R3       # RETURN TO CALLED FUNCTION  

HARDWARE_INTERRUPT_OUTPUT_PRINT:
    XOR OUTR, OUTR
    ADD OUTR, R0
    PRINT_OUTPUT
    JMP RETURN_FROM_HARDWARE_INTERRUPT_OUTPUT_PRINT

SOFTWARE_INTERRUPT_INPUT:       # SOFTWARE INTERRUPT FOR INPUT
                                # IT WILL SAVE INPUT TO STACK
    JMP HARDWARE_INTERRUPT_INPUT

    RETURN_FROM_HARDWARE_INTERRUPT_INPUT:
        XOR R0, R0       # RESET (R0)        
        ADD R0, INR      # SAVE INPUT DATA (INPUT REGISTER) TO R0 

        SUB SP, 1        # SET STACK TO CURRENT STACK LOCATION
        LOAD R3, [SP]    # POP RETURN ADDRESS TO R3 FROM STACK

        JMPREG R3        # RETURN TO CALLED FUNCTION

HARDWARE_INTERRUPT_INPUT:       # HARDWARE INTERRUPT FOR INPUT WHICH WILL BE CALLED BY HARDWARE
                                # ITSELF TO LET SOFTWARE KNOW THAT USER HAS ENTERED THE INPUT
    WAITING_FOR_INPUT:
        ACCEPT_INPUT   
        JMP WAITING_FOR_INPUT       # WAITING FOR INPUT

    HARDWARE_INTERRUPT_INPUT_FOUND: # HARDWARE SAYS THAT INPUT IS FOUND
        JMP RETURN_FROM_HARDWARE_INTERRUPT_INPUT

MAIN: # MAIN FUNCTION WITH NO ARGUMENT
    XOR SP, SP # RESET STACK POINTER (SP) WHICH IS ORIGINALLY R5

    XOR R0, R0          # RESET (R0)
    ADD R0, 12          # R0 = 12 => IT SAVES RETURN ADDRESS 12 WHICH 
                        # WILL JUMP TO RETURN_FROM_SOFTWARE_INTERRUPT_INPUT1
                        
    STORE [SP], R0      # PUSH RETURN ADDRESS TO STACK 
    ADD SP, 1           # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP SOFTWARE_INTERRUPT_INPUT # WAITING FOR USER INPUT. RETURN VALUE WILL BE SAVED IN R0
RETURN_FROM_SOFTWARE_INTERRUPT_INPUT1:
    XOR R1, R1          # RESET (R1)
    ADD R1, R0          # SAVE FIRST INPUT DATA (R0) TO R1

    XOR R0, R0          # RESET (R0)
    ADD R0, 13          # R0 = 13 => IT SAVES RETURN ADDRESS 13 WHICH 
                        # WILL JUMP TO RETURN_FROM_SOFTWARE_INTERRUPT_INPUT2

    STORE [SP], R0      # PUSH RETURN ADDRESS TO STACK 
    ADD SP, 1           # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP SOFTWARE_INTERRUPT_INPUT # WAITING FOR USER INPUT. RETURN VALUE WILL BE SAVED IN R0
RETURN_FROM_SOFTWARE_INTERRUPT_INPUT2:

    ADD R0, R1          # R0 = R0 + R1

    XOR R2, R2          # RESET (R2)
    ADD R2, 14          # R2 = 14 => IT SAVES RETURN ADDRESS 14 WHICH 
                        # WILL JUMP TO RETURN_FROM_SOFTWARE_INTERRUPT_OUTPUT_PRINT

    STORE [SP], R2      # PUSH RETURN ADDRESS TO STACK 
    ADD SP, 1           # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP SOFTWARE_INTERRUPT_OUTPUT_PRINT     # OUTPUT DATA WILL BE IN R0
RETURN_FROM_SOFTWARE_INTERRUPT_OUTPUT_PRINT:
    JMP EXIT

EXIT:          # PUT CPU INTO NOP (NO OPERATION)
    JMP EXIT       # PUT CPU INTO NOP (NO OPERATION)