START 16    # PROGRAM WILL BE LOADED AT ADDRESS 16 IN RAM
            # IT WILL FILL ALL PREVIOUS ADDRESSES (0-15) WITH 0 AND 
            # PHYSICAL ADDRESS = LOGICAL ADDRESS + RELOCATION VALUE (16)

# ALL THE ARGUMENTS AND RETURN VALUES ARE STORED IN STACK 
# WHICH STARTS FROM ADDRESS 0
XOR SP, SP # RESET STACK POINTER (SP) WHICH IS ORIGINALLY R5

Main: # MAIN FUNCTION WITH NO ARGUMENT
    # ALL THE LOCAL VARIABLES WILL BE SAVED FROM ADDRESS 6
    XOR R3, R3       # RESET (R3)
    ADD R3, 5        # R3 = 5
    STORE [6], R3    # D = [6] = R3 = 2 

    XOR R0, R0  # RESET (R0)
    XOR R1, R1  # RESET (R1)

    ADD R0, 1  # R0 = 1 => IT SAVES FIRST ARGUMENT OF VALUE 1
    ADD R1, 2  # R1 = 2 => IT SAVES SECOND ARGUMENT OF VALUE 2

    # ARGUMENTS ARE ALWAYS PUSHED IN REVERSE ORDER INTO STACK
    STORE [SP], R3  # PUSH D TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R1  # PUSH 2 (SECOND ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    STORE [SP], R0  # PUSH 1 (FIRST ARGUMENT) TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP Add

Return_From_Add:
    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R2, [SP]   # POP RETURN VALUE FROM STACK 
    STORE [7], R2   # SAVE E 

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R3, [SP]   # POP D FROM STACK 

    ADD R3, 1       # D = D + 1
    STORE [6], R3   # SAVE D

    JMP Exit 

Add: # ADD FUNCTION WITH A & B ARGUMENTS
    # SINCE ADD FUNCTION USES A, B AND C WHICH ARE LOCAL VARIABLES
    # OMITING THEM AND USING ONLY REGISTERS ARE ENOUGH
    # BECAUSE IT WILL NOT CHANGE MEANING OF PROGRAM

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R0, [SP]   # POP A (R0) FROM STACK

    SUB SP, 1       # SET STACK ADDRESS TO CURRENT MEMORY/STACK LOCATION
    LOAD R1, [SP]   # POP B (R1)FROM STACK

    ADD R0, R1      # A = A + B (R0 = R0 + R1)

    STORE [SP], R0  # PUSH RETURN VALUE TO STACK 
    ADD SP, 1       # SET STACK ADDRESS TO NEXT MEMORY/STACK LOCATION

    JMP Return_From_Add  # RETURN WITH RETURN VALUE

Exit:              # PUT CPU INTO NOP (NO OPERATION)
    JMP Exit       # PUT CPU INTO NOP (NO OPERATION)
